Need proper shutdown hook for cleaning up platform on termination.
The current code (eclipse 3.0 and before) handles shutdown with the following code snippet in the InternalBootLoader.run() method: public static Objec
t run(String applicationName/*R1.0 compatibility*/, URL pluginPathLocation/*R1.0 compatibility*/, String location, String[] args, Runnable handler) th
rows Exception { ....
try { result = runnable.run(applicationArgs); } catch (Throwable e) { e.printStackTrace(); throw new InvocationTargetException(e); } finally { shutdow
n(); } ...
} The shutdown method is used to clean up the platform at shutdown.
Among other things, it goes through and tells all plugins to shutdown and it also invokes the code to remove the workspace .lock file.
The problem with this code is that the finally clause is not guaranteed to run.
It will only run if the java code in the runnable.run() method exits normally or throws a Throwable.
However, it is not guaranteed to run if the java run-time environment recieves a termination signal from the operating system.
The symptoms of the problem are that plugins are not properly shutdown and the .lock file is left orphaned, causing the user to have to manually remov
e it to release the workspace.
Granted, some terminations are impossible to service (such as a poweroff or a blue-screen event).
However, there are many situations where the OS sends a signal to the runtime that could be handled gracefully 
- for example the user logs out or shuts down his computer gracefully, or sends an 'end process' command (for example from the Task Manager in Windows
) or closes the 
-consolelog window, if that is open.
The java runtime allows you to catch some of these signal events by registering a shutdown hook object with the Runtime using: Runtime.getRuntime().ad
dShutdownHook(Runnable hook); When the runtime terminates, it will try to execute all Runnable objects that are registered this way.
This will generally work fine in most runtime termination scenarios and is the preferred way to do final cleanup of temporary files and data at the en
d of a runtime session.
It is true that even this is not a catch all, though.
For example, if the user sends an 'end process' signal and then prematurely clicks on 'End Now' in the progress dialog, a long-duration shutdown hook 
may be interrupted prematurely.
Thus it is preferable that the hook not do any activities that take a long time to complete.
Given this, the preferred way to have the shutdown() method invoked in the InternalBootLoader.run() method, above, would be to create a Runnable that 
invokes it like so: public static Object run(String applicationName/*R1.0 compatibility*/, URL pluginPathLocation/*R1.0 compatibility*/, String locati
on, String[] args, Runnable handler) throws Exception { ....
Runnable shutDownHook= new Runnable(){ public void run(){ InternalBootLoader.shutdown(); } } Runtime.getRuntime().addShutdownHook(shutDownHook); try {
 result = runnable.run(applicationArgs); } catch (Throwable e) { e.printStackTrace(); throw new Invocat