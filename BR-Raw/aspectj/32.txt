An package-level abstract generic privileged aspect, which extends an abstract generic aspect, gives a IlligalStateException on a method call in around advice
Build Identifier: AJDT Version: 2.1.3.e37x-20110628-1900 / AspectJ version: 1.6.12.20110613132200 / eclipse.buildId=M20120208-0800
around advice targetting a generic constructor call in a package visability  generic privileged abstract apsect, which extends a abstract generic aspect gives a compiler error when in this around advice a method call is made to a method defined in the aspect, superaspect or abstract defined methods. This only affects around advice and only when the aspect is package-visible and privileged.
Workaround: either make the aspect public or remove privileged.
Compiler output:
Compile error: IllegalStateException thrown: Use generic type, not parameterized type
StackTrace:
java.lang.IllegalStateException: Use generic type, not parameterized type
at org.aspectj.weaver.ResolvedTypeMunger.<init>(ResolvedTypeMunger.java:72)
at org.aspectj.weaver.PrivilegedAccessMunger.<init>(PrivilegedAccessMunger.java:31)
at org.aspectj.weaver.CrosscuttingMembers.addPrivilegedAccesses(CrosscuttingMembers.java:232)
at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:756)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:89)
at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:69)
at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:512)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.ensureWeaverInitialized(AjPipeliningCompilerAdapter.java:529)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:509)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)
at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)
at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:652)
at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:305)
at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:185)
at org.aspectj.ajde.core.internal.AjdeCoreBuildManager.performBuild(AjdeCoreBuildManager.java:127)
at org.aspectj.ajde.core.AjCompiler.build(AjCompiler.java:91)
at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:257)
at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)
at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Session data:
eclipse.buildId=M20120208-0800
java.version=1.6.0_22
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=nl_NL
Command-line arguments:  -data C:workspace -os win32 -ws win32 -arch x86_64
Reproducible: Always
Steps to Reproduce:
1. In a empty AspectJ project create the file Foo.java:
import java.util.LinkedList;
public class Foo {
public LinkedList bar()
{
new LinkedList();
return null;
}
}
2. Create the file FooAspect.aj containing:
import java.util.AbstractList;
import java.util.List;
abstract aspect FooAspectParent<T extends List>
{
protected int getNumber(int k)
{
return -1*k;
}
}
abstract privileged aspect FooAspect<T extends AbstractList> extends FooAspectParent<T> {
pointcut pc():  call(T.new());
T around():pc()
{
//getNumber(1); //<-- method call to superAspect fails
//method();  // <-- method call to abstract local defined method fails
//localMethod(); //<-- method call to local private method fails
Math.random(); //<-- works
hashCode(); //<-- works
return null;
}
private void localMethod(){}

protected abstract T method();
}
3. Uncomment one or more of the three commentted functions calls in the around advice and the compiler will reproduce the error.
(note: this example with List which is a generic object is just for illustration of hierachy, this problem occured on production code when doing the same with non-generic, but hierachal objects. This way was the easiest to issolate and reproduce the bug the fastest.)