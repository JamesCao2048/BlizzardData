XLint warning for call PCD's using subtype of defining type
Some would like an XLint compiler warning when the user in a call PCD specifies
a declaring type that is not the defining type, because that constrains the join
points to those whose bytecode signature contain the specified type as the
declaring type.  e.g.,
----
class A { void run() {} }
class B extends A {}
aspect C {
before() : call(void B.run()) { } // warn here
}
public class Main {
public static void main(String[] args) {
// ok with -1.4; otherwise, becomes A.run in bytecode
new B().run();
// never works - compile-time type of reference is A, not B
((A) new B()).run();
}
----
This warning is useful for two reasons.  First, the user probably intended that
any call to an instance of that object be picked out (regardless of the
compile-time type of the reference used to make the call), and thus should use
target(B) && call(void run())
(This suggestion could be in the XLint message.)
Second, older compilers (i.e., compilers not using -1.4) would incorrectly
specify the declaring type of the method call as the first type in the hierarchy
which defined the method, so even if the user meant to constrain the join point
by the compile-time reference type, the bytecode signature could be incorrect
and the pointcut fail to pick out the join point.
One problem with this XLint warning is that is also picks out valid declare
warning/error statements enforcing requirements at compile-time about the type
of the reference used to invoke a method (e.g., when using a static reference of
the wrong type).  So perhaps the default level should be ignore.
See also  bug 41888 .