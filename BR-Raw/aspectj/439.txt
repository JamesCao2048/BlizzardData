In some cases the structure model doesn't contain the "matches declare" relationship
With a project containing one class and one aspect:
public class HelloClass {
public static void main(String[] args) {
new HelloClass().sayHello();
}

public void sayHello() {
System.out.println("Hello");
}

}
public aspect A1 {
pointcut test() : get(* System.out);

declare warning : test() && !within(A1)
: "test warning";

pointcut anotherTest() :
execution(void HelloClass.sayHello(..));

after() returning : anotherTest() {
System.out.println("returning....");
}

}
The following is returned from the structure model:
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target:
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses
pointcut, target: A1.anotherTest()
asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises,
target: HelloClass.sayHello()
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target:
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target:
A1.afterReturning(): anotherTest..
asmRelMap entry: A1.declare warning: "test warning", relationship: matched by,
target: HelloClass.sayHello()
In other words, the model is saying that there are two entries the same:
asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target:
A1.afterReturning(): anotherTest..
whereas one of these should be the "matches declare" relationship relating to
the declare warning.
Changing the aspect to be:
public aspect A1 {
pointcut test() : get(* System.out);

declare warning : test() && !within(A1)
: "test warning";

pointcut anotherTest() :
execution(void HelloClass.sayHello(..));

after() returning : anotherTest() {
System.out.println("returning....");
}

after() returning : test() {
System.out.println("returning again!");
}

}
means that the IRelationshipMap does now contain the "matches declare"
relationship.
This is all with AspectJ 5 M1.